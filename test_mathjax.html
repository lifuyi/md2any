<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>MathJax SVG to Base64 Test</title>
    <script>
        // MathJax configuration
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            svg: {
                fontCache: 'global'
            }
            // Removed the startup configuration that might be causing issues
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>
    <h1>MathJax SVG to Base64 Test</h1>
    
    <div id="content">
        <p>When $a \ne 0$, the solution to the equation $ax^2 + bx + c = 0$ is:</p>
        <p>$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}$$</p>
    </div>
    
    <button onclick="testConversion()">Test SVG to Base64 Conversion</button>
    <div id="result"></div>
    
    <script>
        // Utility function to convert SVG to base64 data URL
        function svgToBase64DataURL(svgElement) {
            try {
                // Clone the SVG element to avoid modifying the original
                const clonedSvg = svgElement.cloneNode(true);
                
                // Ensure proper namespace on the cloned element
                if (!clonedSvg.hasAttribute('xmlns')) {
                    clonedSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                }
                
                // Process the SVG to make it more self-contained
                const allStyleSheets = document.styleSheets;
                
                // Properly serialize the SVG element with all namespaces
                const serializer = new XMLSerializer();
                let svgString = serializer.serializeToString(clonedSvg);
                
                // Ensure SVG has proper namespace and other required attributes
                if (!svgString.includes('xmlns="http://www.w3.org/2000/svg"')) {
                    svgString = svgString.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
                }
                
                // Add xmlns:xlink if not present (for MathJax fonts)
                if (svgString.includes('xlink:href') && !svgString.includes('xmlns:xlink="http://www.w3.org/1999/xlink"')) {
                    svgString = svgString.replace('<svg', '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
                }
                
                console.log('Processed SVG:', svgString.substring(0, 200) + '...');
                
                // Convert to base64 using btoa (more reliable than encodeURIComponent)
                // First, we need to handle UTF-8 encoding properly
                const base64Encoded = btoa(unescape(encodeURIComponent(svgString)));
                return `data:image/svg+xml;base64,${base64Encoded}`;
            } catch (error) {
                console.warn('Failed to convert SVG to base64:', error);
                
                // Try a fallback approach for MathJax
                try {
                    // If the standard approach fails, try to get the outerHTML directly
                    const svgString = svgElement.outerHTML;
                    
                    // Ensure proper namespace
                    let processedSvg = svgString;
                    if (!processedSvg.includes('xmlns="http://www.w3.org/2000/svg"')) {
                        processedSvg = processedSvg.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
                    }
                    
                    // Add xmlns:xlink if not present
                    if (processedSvg.includes('xlink:href') && !processedSvg.includes('xmlns:xlink="http://www.w3.org/1999/xlink"')) {
                        processedSvg = processedSvg.replace('<svg', '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
                    }
                    
                    const base64Encoded = btoa(unescape(encodeURIComponent(processedSvg)));
                    return `data:image/svg+xml;base64,${base64Encoded}`;
                } catch (fallbackError) {
                    console.warn('Fallback SVG conversion also failed:', fallbackError);
                    return null;
                }
            }
        }
        
        // Wait for MathJax to render automatically
        setTimeout(() => {
            if (typeof window.MathJax !== 'undefined' && window.MathJax.typesetPromise) {
                window.MathJax.typesetPromise([document.getElementById('content')]).then(() => {
                    console.log('MathJax rendering completed');
                }).catch((error) => {
                    console.warn('MathJax rendering failed:', error);
                });
            }
        }, 2000);
        
        function testConversion() {
            const content = document.getElementById('content');
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content.innerHTML;
            
            // Convert MathJax SVG elements to images for better clipboard compatibility
            const mathJaxElements = tempDiv.querySelectorAll('mjx-container[jax="SVG"]');
            
            console.log('Found', mathJaxElements.length, 'MathJax elements');
            
            mathJaxElements.forEach((container, index) => {
                const svg = container.querySelector('svg');
                if (svg) {
                    try {
                        // Convert SVG to base64 data URL using our reusable function
                        const dataURL = svgToBase64DataURL(svg);
                        
                        if (dataURL) {
                            console.log('Data URL length:', dataURL.length);
                            
                            // Create img element to replace the MathJax container
                            const img = document.createElement('img');
                            img.src = dataURL;
                            img.alt = 'Math formula';
                            img.style.verticalAlign = 'middle';
                            img.setAttribute('data-math', 'true'); // Mark as math element for debugging
                            
                            // Copy dimensions and important attributes from original SVG
                            const width = svg.getAttribute('width');
                            const height = svg.getAttribute('height');
                            const style = svg.getAttribute('style');
                            
                            if (width) img.style.width = width;
                            if (height) img.style.height = height;
                            if (style) img.setAttribute('style', style + '; vertical-align: middle;');
                            
                            // Replace the MathJax container with the image
                            container.parentNode.replaceChild(img, container);
                            
                            console.log('Successfully converted MathJax element', index);
                        }
                    } catch (error) {
                        console.warn('Failed to convert MathJax SVG to image:', error);
                        // Keep original structure as fallback
                    }
                } else {
                    console.warn('No SVG found in MathJax container', index);
                }
            });
            
            // Display the result
            document.getElementById('result').innerHTML = tempDiv.innerHTML;
            
            // Log the result for debugging
            console.log('Conversion completed. Result HTML:', tempDiv.innerHTML.substring(0, 500) + '...');
        }
    </script>
</body>
</html>