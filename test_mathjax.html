<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>MathJax SVG to Base64 Test</title>
    <script>
        // MathJax configuration
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            svg: {
                fontCache: 'global'
            }
            // Removed the startup configuration that might be causing issues
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>
    <h1>MathJax SVG to Base64 Test</h1>
    
    <div id="content">
        <p>When $a \ne 0$, the solution to the equation $ax^2 + bx + c = 0$ is:</p>
        <p>$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}$$</p>
    </div>
    
    <button onclick="testConversion()">Test SVG to Base64 Conversion</button>
    <div id="result"></div>
    
    <script>
        // Enhanced utility function to convert SVG to base64 data URL
        function svgToBase64DataURL(svgElement) {
            try {
                // Clone the SVG element to avoid modifying the original
                const clonedSvg = svgElement.cloneNode(true);
                
                // Ensure proper SVG namespace
                clonedSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                
                // Add xlink namespace if needed (for MathJax font references)
                if (clonedSvg.innerHTML.includes('xlink:href') || clonedSvg.innerHTML.includes('href')) {
                    clonedSvg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
                }
                
                // Collect and embed any referenced fonts or styles from MathJax
                const mathJaxStyles = collectMathJaxStyles();
                if (mathJaxStyles) {
                    const styleElement = document.createElement('style');
                    styleElement.textContent = mathJaxStyles;
                    clonedSvg.insertBefore(styleElement, clonedSvg.firstChild);
                }
                
                // Handle font definitions - convert use elements to embedded paths
                processFontReferences(clonedSvg);
                
                // Serialize the SVG
                const serializer = new XMLSerializer();
                let svgString = serializer.serializeToString(clonedSvg);
                
                // Clean up and validate the SVG string
                svgString = cleanupSvgString(svgString);
                
                console.log('Processed SVG length:', svgString.length);
                console.log('SVG preview:', svgString.substring(0, 300) + '...');
                
                // Convert to base64 - try multiple encoding methods
                return encodeToBase64(svgString);
                
            } catch (error) {
                console.error('Primary SVG conversion failed:', error);
                return fallbackConversion(svgElement);
            }
        }
        
        // Helper function to collect MathJax styles
        function collectMathJaxStyles() {
            try {
                let styles = '';
                
                // Look for MathJax style elements
                const styleElements = document.querySelectorAll('style');
                for (const styleEl of styleElements) {
                    if (styleEl.textContent.includes('mjx-') || styleEl.textContent.includes('MathJax')) {
                        styles += styleEl.textContent + '\n';
                    }
                }
                
                // Also check stylesheets
                for (const sheet of document.styleSheets) {
                    try {
                        if (sheet.href && sheet.href.includes('mathjax')) {
                            // Can't access cross-origin stylesheets, skip
                            continue;
                        }
                        
                        for (const rule of sheet.cssRules || []) {
                            if (rule.cssText && (rule.cssText.includes('mjx-') || rule.cssText.includes('MathJax'))) {
                                styles += rule.cssText + '\n';
                            }
                        }
                    } catch (e) {
                        // Skip inaccessible stylesheets
                        console.warn('Could not access stylesheet:', e);
                    }
                }
                
                return styles;
            } catch (error) {
                console.warn('Failed to collect MathJax styles:', error);
                return '';
            }
        }
        
        // Helper function to process font references in SVG
        function processFontReferences(svgElement) {
            try {
                // Find all <use> elements that reference fonts
                const useElements = svgElement.querySelectorAll('use');
                if (useElements.length === 0) return;
                
                // Create defs section if it doesn't exist
                let defs = svgElement.querySelector('defs');
                if (!defs) {
                    defs = document.createElement('defs');
                    svgElement.insertBefore(defs, svgElement.firstChild);
                }
                
                // Method 1: Access MathJax's global font cache
                // MathJax 3 with fontCache: 'global' stores fonts in a global cache
                if (window.MathJax && window.MathJax.svg && window.MathJax.svg.fontCache) {
                    try {
                        // Get the global font cache SVG element
                        const fontCache = window.MathJax.svg.fontCache;
                        if (fontCache && fontCache.id) {
                            // Find the global font cache element in the document
                            const globalFontCache = document.getElementById(fontCache.id);
                            if (globalFontCache) {
                                // Clone all children from global font cache to our SVG's defs
                                const children = globalFontCache.children;
                                for (let i = 0; i < children.length; i++) {
                                    const child = children[i];
                                    const id = child.getAttribute('id');
                                    if (id && !defs.querySelector(`#${id}`)) {
                                        defs.appendChild(child.cloneNode(true));
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.log('Could not access MathJax global font cache:', e);
                    }
                }
                
                // Method 2: Look for global MathJax definitions in the document
                // MathJax creates global <defs> elements that contain font definitions
                const globalMathJaxDefs = document.querySelectorAll('defs[id*="MathJax"], defs[id*="mjx"]');
                globalMathJaxDefs.forEach(globalDef => {
                    // Clone all children from global defs to our SVG's defs
                    const children = globalDef.children;
                    for (let i = 0; i < children.length; i++) {
                        const child = children[i];
                        const id = child.getAttribute('id');
                        if (id && !defs.querySelector(`#${id}`)) {
                            defs.appendChild(child.cloneNode(true));
                        }
                    }
                });
                
                // Method 3: Look for MathJax's internal SVG structure
                const mathJaxSvgs = document.querySelectorAll('svg[data-mjx]');
                mathJaxSvgs.forEach(mjxSvg => {
                    const mjxDefs = mjxSvg.querySelector('defs');
                    if (mjxDefs) {
                        const children = mjxDefs.children;
                        for (let i = 0; i < children.length; i++) {
                            const child = children[i];
                            const id = child.getAttribute('id');
                            if (id && !defs.querySelector(`#${id}`)) {
                                defs.appendChild(child.cloneNode(true));
                            }
                        }
                    }
                });
                
                // Method 4: Look for any mjx-container elements that might contain definitions
                const mjxContainers = document.querySelectorAll('mjx-container');
                mjxContainers.forEach(container => {
                    const containerDefs = container.querySelector('defs');
                    if (containerDefs) {
                        const children = containerDefs.children;
                        for (let i = 0; i < children.length; i++) {
                            const child = children[i];
                            const id = child.getAttribute('id');
                            if (id && !defs.querySelector(`#${id}`)) {
                                defs.appendChild(child.cloneNode(true));
                            }
                        }
                    }
                });
                
                // Method 5: Direct access to referenced elements
                useElements.forEach(useEl => {
                    const href = useEl.getAttribute('href') || useEl.getAttribute('xlink:href');
                    if (href && href.startsWith('#')) {
                        // Try to find the referenced element in the document
                        const referencedId = href.substring(1);
                        let referencedElement = document.getElementById(referencedId);
                        
                        if (!referencedElement) {
                            // Look in MathJax's internal defs
                            const mathJaxContainers = document.querySelectorAll('mjx-container');
                            for (const container of mathJaxContainers) {
                                const found = container.querySelector(`#${referencedId}`);
                                if (found) {
                                    referencedElement = found;
                                    break;
                                }
                            }
                        }
                        
                        if (referencedElement) {
                            // Clone the referenced element into a defs section if not already present
                            let defs = svgElement.querySelector('defs');
                            if (!defs) {
                                defs = document.createElement('defs');
                                svgElement.insertBefore(defs, svgElement.firstChild);
                            }
                            
                            // Only add if not already present
                            if (!defs.querySelector(`#${referencedId}`)) {
                                const clonedRef = referencedElement.cloneNode(true);
                                defs.appendChild(clonedRef);
                            }
                        }
                    }
                });
            } catch (error) {
                console.warn('Failed to process font references:', error);
            }
        }
        
        // Helper function to clean up SVG string
        function cleanupSvgString(svgString) {
            // Remove any script tags for security
            svgString = svgString.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
            
            // Ensure proper XML structure
            if (!svgString.includes('<?xml')) {
                svgString = '<?xml version="1.0" encoding="UTF-8"?>\n' + svgString;
            }
            
            // Fix any malformed attributes
            svgString = svgString.replace(/(\w+)=([^"\s>]+)/g, '$1="$2"');
            
            return svgString;
        }
        
        // Helper function to encode SVG to base64 with multiple fallback methods
        function encodeToBase64(svgString) {
            // Method 1: Standard btoa with proper UTF-8 handling
            try {
                const base64 = btoa(unescape(encodeURIComponent(svgString)));
                const dataURL = `data:image/svg+xml;base64,${base64}`;
                
                // Test if the data URL is valid by trying to create an image
                return testAndReturnDataURL(dataURL, 'Method 1 (btoa with UTF-8)');
            } catch (error) {
                console.warn('Method 1 encoding failed:', error);
            }
            
            // Method 2: TextEncoder approach
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(svgString);
                const base64 = btoa(String.fromCharCode(...data));
                const dataURL = `data:image/svg+xml;base64,${base64}`;
                
                return testAndReturnDataURL(dataURL, 'Method 2 (TextEncoder)');
            } catch (error) {
                console.warn('Method 2 encoding failed:', error);
            }
            
            // Method 3: URL encoding (not base64, but often works)
            try {
                const encoded = encodeURIComponent(svgString);
                const dataURL = `data:image/svg+xml,${encoded}`;
                
                return testAndReturnDataURL(dataURL, 'Method 3 (URL encoding)');
            } catch (error) {
                console.warn('Method 3 encoding failed:', error);
            }
            
            console.error('All encoding methods failed');
            return null;
        }
        
        // Helper function to test if a data URL is valid
        function testAndReturnDataURL(dataURL, methodName) {
            // Basic validation
            if (!dataURL || dataURL.length < 50) {
                throw new Error(`${methodName}: Data URL too short`);
            }
            
            // More sophisticated test could involve creating an image and checking if it loads
            console.log(`${methodName}: Generated data URL of length ${dataURL.length}`);
            return dataURL;
        }
        
        // Fallback conversion function
        function fallbackConversion(svgElement) {
            try {
                console.log('Attempting fallback conversion...');
                
                // Simple approach: just get outerHTML and encode
                let svgString = svgElement.outerHTML;
                
                // Add basic namespace if missing
                if (!svgString.includes('xmlns=')) {
                    svgString = svgString.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
                }
                
                // Try simple base64 encoding
                const base64 = btoa(svgString);
                const dataURL = `data:image/svg+xml;base64,${base64}`;
                
                console.log('Fallback conversion successful, length:', dataURL.length);
                return dataURL;
                
            } catch (error) {
                console.error('Fallback conversion also failed:', error);
                return null;
            }
        }
        
        // Wait for MathJax to render automatically
        setTimeout(() => {
            if (typeof window.MathJax !== 'undefined' && window.MathJax.typesetPromise) {
                window.MathJax.typesetPromise([document.getElementById('content')]).then(() => {
                    console.log('MathJax rendering completed');
                }).catch((error) => {
                    console.warn('MathJax rendering failed:', error);
                });
            }
        }, 2000);
        
        function testConversion() {
            const content = document.getElementById('content');
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content.innerHTML;
            
            // Convert MathJax SVG elements to images for better clipboard compatibility
            const mathJaxElements = tempDiv.querySelectorAll('mjx-container[jax="SVG"]');
            
            console.log('Found', mathJaxElements.length, 'MathJax elements');
            
            // Process elements sequentially to handle async operations
            (async () => {
                for (let index = 0; index < mathJaxElements.length; index++) {
                    const container = mathJaxElements[index];
                    const svg = container.querySelector('svg');
                    if (svg) {
                        try {
                            // Convert SVG to base64 data URL using our reusable function
                            const dataURL = svgToBase64DataURL(svg);
                            
                            if (dataURL) {
                                console.log('Data URL length:', dataURL.length);
                                
                                // Create img element to replace the MathJax container
                                const img = document.createElement('img');
                                img.src = dataURL;
                                img.alt = 'Math formula';
                                img.style.verticalAlign = 'middle';
                                img.setAttribute('data-math', 'true'); // Mark as math element for debugging
                                
                                // Copy dimensions and important attributes from original SVG
                                const width = svg.getAttribute('width');
                                const height = svg.getAttribute('height');
                                const style = svg.getAttribute('style');
                                
                                if (width) img.style.width = width;
                                if (height) img.style.height = height;
                                if (style) img.setAttribute('style', style + '; vertical-align: middle;');
                                
                                // Test if the image loads properly before replacing
                                img.onload = function() {
                                    console.log(`✓ MathJax element ${index} image loaded successfully`);
                                    // Validate that the image actually has content
                                    if (this.naturalWidth === 0) {
                                        console.warn(`✗ MathJax element ${index} image has no content`);
                                    }
                                };
                                img.onerror = function() {
                                    console.error(`✗ MathJax element ${index} image failed to load`);
                                };
                                
                                // Replace the MathJax container with the image
                                container.parentNode.replaceChild(img, container);
                                
                                console.log('Successfully converted MathJax element', index);
                            }
                        } catch (error) {
                            console.warn('Failed to convert MathJax SVG to image:', error);
                            // Keep original structure as fallback
                        }
                    } else {
                        console.warn('No SVG found in MathJax container', index);
                    }
                }
                
                // Display the result
                document.getElementById('result').innerHTML = tempDiv.innerHTML;
                
                // Log the result for debugging
                console.log('Conversion completed. Result HTML:', tempDiv.innerHTML.substring(0, 500) + '...');
            })();
        }
    </script>
</body>
</html>